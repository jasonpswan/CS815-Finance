library(gramEvol)

# Given the title of this class, I decided to look at Financial Data for the purposes of this assignment
# I have chosen to look at Tesla, given it's strong links to AI & Machine Learning
# The Quantmod library (introduced for assignment 2 helped me find the appropriate data)
# Rather than splitting the data into training and test sets I have instead chosen to look at 2 consecutive years
# I will evolve a function based on 2018 stock price data and evaluate it on 2019 stock price data

library(quantmod)

mystock <- c("TSLA")
getSymbols(mystock, src = "yahoo", from = "2018-01-01", to = "2019-12-01")

# Get information for TESLA over a 1 year period for the purposes of creating this program.
tesla <- (TSLA)
tesla <- subset(TSLA, select = TSLA.Adjusted)
tesla

# We can check how many items we have listed here
count(tesla)
# So we have 482 points within the data here

# We can look at a quick summary of the data which we have here
summary(tesla)
# We have values for the min (179) and the max (379.6)
# We can see the mean (291.8) and the median (298)
# We can also see the 1st and 3rd quartiles (255.6 & 331.3)


# Initiate the Time Series


# We can transform the data to be in the form of a time series as follows
teslats <- ts(tesla)
teslats

# Now to plot the time series data assocated with bonds we can do the following
plot(teslats)
title(main = "Time Series Plot for Tesla 2019")
# Tesla's stock prices look as if they were pretty volatile between 2018 & 2019
# I'm sure Elon Musk previously blamed this on people shorting stocks.....

# The stock price is overall very volatile.
# There is high peaks and low troughs, with it starting and finishing the period ay around the same price
# The does not seem to be any seasonal influence with it performing poorly around 60 days in and around 190 days in, before plummeting around th 1 year mark.
# The high points also cannot be explained by any kind of seasonal behaviour.
# Perhaps by considering the actions of the company at the time all of these peaks and troughs could be further explained.

# We could consider an additive model to describe the time series.
# Let's use a log transformation and plot the data again.
logteslats <- log(teslats)
plot.ts(logteslats)
title(main = "Time Series Plot for Tesla 2019 (LOG)")
# Ok so that makes no difference and the plot looks almost identical... there goes that idea.


# Details of the GP

# Window size 5
window5 <- data.frame(x5=Lag(teslats,5), x4=Lag(teslats,4), x3=Lag(teslats,3), x2=Lag(teslats,2), x1=Lag(teslats,1), teslats)
names(window5) <- c('x5','x4','x3', 'x2', 'x1', 'x')


# drop first 5 rows and keep the last 50 back for testing:
traindata <- teslats[6:431,]
traindata
testdata <- teslats[432:482,]
testdata

# Define the rules is the initial step for this.

ruleDef <- list(expr = grule(op(expr, expr), func(expr), var),
                func = grule(sin, cos, tan, exp, log),
                op = grule('+', '-', '*'),
                var = grule(x))

grammarDef <- CreateGrammar(ruleDef)
grammarDef

# So I have included the obvious ones here, which are plus, minus and times (which should cover to the power too).
# Plus I've included sin, tan, cos, and exp.
# Tried using Sinh, Cosh, Tanh, log as possible functions.
# NaN were found when using these so they were eliminated as possible choices.

# Fitness Function (RMSE)- because this is a form of regression.
newFitFunc <- function(expr) {
  result <- eval(expr)
  if (any(is.nan(result)))
    return(Inf)
  return (sqrt(mean((mydata$x - result)^2)))
}

# Runs the Grammatical Evolution on Window size 5.
gew5 <- GrammaticalEvolution(grammarDef, SymRegFitFunc, terminationCost = 0.1, iterations = 2500, max.depth = 5)
# The outcome of ge on Window size 5.
gew5
# Look at the Best Expresion of the ge on Window size 5.
gew5$best$expressions
#Look at the values generated by training.
eval(gew5$best$expressions)
# Consider the performance over the test data.
mydata <- testdata
eval(gew5$best$expressions)



# Window size 4
window4 <- data.frame(x4=Lag(teslats,4), x3=Lag(teslats,3), x2=Lag(teslats,2), x1=Lag(teslats,1), teslats)
names(window4) <- c('x4','x3', 'x2', 'x1', 'x')


# drop first 4 rows and keep the last 50 back for testing:
traindata <- teslats[5:431,]
traindata
testdata <- teslats[432:482,]
testdata

# Define the rules is the initial step for this.

ruleDef <- list(expr = grule(op(expr, expr), func(expr), var),
                func = grule(sin, cos, tan, exp, log),
                op = grule('+', '-', '*'),
                var = grule(x))

grammarDef <- CreateGrammar(ruleDef)
grammarDef

# So I have included the obvious ones here, which are plus, minus and times (which should cover to the power too).
# Plus I've included sin, tan, cos, and exp.
# Tried using Sinh, Cosh, Tanh, log as possible functions.
# NaN were found when using these so they were eliminated as possible choices.

# Fitness Function (RMSE)- because this is a form of regression.
newFitFunc <- function(expr) {
  result <- eval(expr)
  if (any(is.nan(result)))
    return(Inf)
  return (sqrt(mean((mydata$x - result)^2)))
}

# Runs the Grammatical Evolution on Window size 5.
gew4 <- GrammaticalEvolution(grammarDef, SymRegFitFunc, terminationCost = 0.1, iterations = 2500, max.depth = 5)
# The outcome of ge on Window size 5.
gew4
# Look at the Best Expresion of the ge on Window size 5.
gew4$best$expressions
#Look at the values generated by training.
eval(gew4$best$expressions)
# Consider the performance over the test data.
mydata <- testdata
eval(gew4$best$expressions)



# Window size 6
window6 <- data.frame(x6=Lag(teslats,6), x5=Lag(teslats,5), x4=Lag(teslats,4), x3=Lag(teslats,3), x2=Lag(teslats,2), x1=Lag(teslats,1), teslats)
names(window6) <- c('x6', 'x5', x4','x3', 'x2', 'x1', 'x')


# drop first 6 rows and keep the last 50 back for testing:
traindata <- teslats[7:431,]
traindata
testdata <- teslats[432:482,]
testdata

# Define the rules is the initial step for this.

ruleDef <- list(expr = grule(op(expr, expr), func(expr), var),
                func = grule(sin, cos, tan, exp, log),
                op = grule('+', '-', '*'),
                var = grule(x))

grammarDef <- CreateGrammar(ruleDef)
grammarDef

# So I have included the obvious ones here, which are plus, minus and times (which should cover to the power too).
# Plus I've included sin, tan, cos, and exp.
# Tried using Sinh, Cosh, Tanh, log as possible functions.
# NaN were found when using these so they were eliminated as possible choices.

# Fitness Function (RMSE)- because this is a form of regression.
newFitFunc <- function(expr) {
  result <- eval(expr)
  if (any(is.nan(result)))
    return(Inf)
  return (sqrt(mean((mydata$x - result)^2)))
}

# Runs the Grammatical Evolution on Window size 5.
gew6 <- GrammaticalEvolution(grammarDef, SymRegFitFunc, terminationCost = 0.1, iterations = 2500, max.depth = 5)
# The outcome of ge on Window size 5.
gew6
# Look at the Best Expresion of the ge on Window size 5.
gew6$best$expressions
#Look at the values generated by training.
eval(gew6$best$expressions)
# Consider the performance over the test data.
mydata <- testdata
eval(gew6$best$expressions)

# Comparing window sizes
gew5
gew4
gew6

# The expressions for all 3 window sizes are very different.
# For some reason my results for my best expressions doesn't change between the train and test.
